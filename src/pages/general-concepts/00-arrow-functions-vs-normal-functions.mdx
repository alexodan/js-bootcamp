---
title: Funciones flecha en JavaScript (Arrow functions)
slug: general-concepts/arrow-functions-vs-normal-functions
author: Alexis Diaz
image: /images/buenos-aires.jpeg
---

## Que son las funciones flecha?

Antes de EcmaScript6, no ten√≠amos una forma concisa de escribir funciones, sino
que necesariamente ten√≠amos que usar la siguiente sintaxis:

```js
function felicitar() {
  return 'Felicitaciones!'
}
```

## (No tan) Nueva sintaxis

A partir de 2015 se a√±ade la sintaxis de flecha para escribir funciones.

Las funciones flecha (muchas veces nos encontramos con el t√©rmino en ingl√©s, m√°s
popular, de arrow function) comienzan con una lista de parametros que espera la
funci√≥n:

`(a, b, c)` seguida de una flecha `=>`, seguida a su vez por una expresi√≥n que
devuelve un valor:

`(a, b, c) => a + b + c`

Tambi√©n nos podemos encontrar con las llaves `{}` para el cuerpo de la funci√≥n,
entonces:

```js
const miFuncion = (a, b, c) => {
  console.log('Sumando a, b y c...')
  return a + b + c
}
```

`NOTA: si la funci√≥n solo toma un par√°metro, eres libre de usar par√©ntesis o no, como prefieras! Si en cambio no toma ning√∫n parametro de entrada (o toma m√°s de uno) tienes que usarlos obligadamente.`

## M√°s ejemplos de arrow functions

```js
const felicitar = () => 'Felicitaciones!'
```

```js
const incrementar = num => num + 1
// Al recibir un solo parametro, podemos omitir los par√©ntesis!
```

## Importante! üëÄ

Cuando se hace uso de las llaves `{}` debemos expl√≠citamente usar la keyword
`return` si queremos devolver algo al finalizar la funci√≥n.

_Pero si nuestra funci√≥n es de una sola l√≠nea y usamos la notaci√≥n de flecha,
debemos prescindir del `return`, de lo contrario nos dar√° un error._

En el ejemplo anterior, a√∫n no habiendo usado `return`, la funci√≥n `felicitar`
va a devolver el string 'Felicitaciones!', en cambio la siguiente funci√≥n
devolver√≠a `undefined`:

```js
const felicitar = () => {
  'Felicitaciones!'
}
```

## Para qu√© sirven las funciones flecha?

Como adelantamos en los ejemplos, son muy √∫tiles para declarar funciones de
l√≠nea (`inline functions`), tomemos un caso:

```js
;['this', 'is', 'sparta!'].map(function(str) {
  return str.toUpperCase()
})
// este bloque devolver√° ['THIS','IS','SPARTA!']
```

Con arrow functions podemos tomar ventaja de una sintaxis menos _ruidosa_,
haciendo nuestro c√≥digo m√°s conciso y claro:

```js
;['this', 'is', 'sparta!'].map(str => str.toUpperCase())
// este bloque tambi√©n devolver√° ['THIS','IS','SPARTA!']
```

Tambi√©n son √∫tiles para declarar funciones `curried` de manera m√°s concisa,
√©stas funciones toman m√∫ltiples argumentos, uno a la vez, y retornan una funci√≥n
que espera el pr√≥ximo argumento, y as√≠ sucesivamente:

```js
function sumar(a) {
  return function(b) {
    return a + b
  }
}
```

Con arrow function:

```js
const sumar = a => b => a + b
```

Hay varias cosas adicionales adicionales para mencionar sobre las funciones de
flecha, pero lo dejaremos para la [segunda parte](https://medium.com) de este
art√≠culo!

No dejes que las arrow function te intimiden, al principio tal vez te cueste m√°s
leerlas y entenderlas, pero cu√°nto m√°s las uses m√°s f√°ciles te resultar√°n!
